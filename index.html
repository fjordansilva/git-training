<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Connectis ICT - Curso GIT</title>

		<meta name="description" content="Curso de introducción a GIT">
		<meta name="author" content="Fernando Jordán Silva">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>					
					<a href="http://git-scm.com/" class="image">
						<img width="25%" height="25%" src="images/Git-Logo-White.png" alt="Logo de GIT">
					</a>	
					<br /><br />
					<h1>GIT</h1>					
					<h3>Simplificando la gestión del código</h3>
					<p>
						<small>Por <a href="mailto:fernando.jordan@connectis-ict.es">Fernando Jordán</a> / <a href="http://twitter.com/fjordansilva">@fjordansilva</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>¿Qué es GIT?</h2>
						<p>
							GIT es un sistema de control de versiones. Un sistema de control de versiones registra los cambios 
							realizados sobre un archivo o conjunto de archivos a lo largo del tiempo, de modo que se puedan recuperar versiones específicas más adelante.					
						</p>
						<br />
						<blockquote>
							GIT es una evolución de los sistemas de control de versiones actuales. Es un sistema de control de versiones distribuido.
						</blockquote>
						
						<aside class="notes">
							A continuación se explican los distintos tipos de sistemas y lo que significa que sea un control de versiones distribuido.
						</aside>
					</section>
					<section>
						<h2>Sistemas de control de versiones</h2>
						<ul>
							<li><a href="#/1/2">Sistemas locales</a></li>
							<li><a href="#/1/3">Sistemas centralizados</a></li>
							<li><a href="#/1/4">Sistemas distribuidos</a></li>
						</ul>
					</section>
					<section>
						<h2>Sistemas locales</h2>
						<ul>
							<li>Copiar archivos a otro directorio (marcando la fecha), es un enfoque simple y muy común pero también muy propenso a errores.</li>
							<li>Es fácil olvidar en qué directorio te encuentras, y guardar accidentalmente en el archivo equivocado o sobrescribir archivos que no querías.</li>
						</ul>
						<a href="#" class="image">
							<img width="400" height="336" src="images/Sistemas-Locales.png" alt="Sistemas locales" />
						</a>
						
						<aside class="notes">
							Para hacer frente a este problema, los programadores desarrollaron hace tiempo VCSs locales que contenían una simple base de datos en la que se llevaba registro de todos los cambios realizados sobre los archivos.
						</aside>
					</section>
					<section>
						<h2>Sistemas centralizados</h2>
						<ul>
							<li>Se necesita colaboración entre desarrolladores.</li>
							<li>Se crean los sistemas de colaboración centralizados (Ej: CVS, SVN...): único servidor central y varios clientes que acceden y descargan/modifican la información.</li>
							<li>Desventajas: Punto de fallo único al ser un servidor central. Con cada rama/tag el código se duplica y aumenta el espacio en disco.</li>
						</ul>
						<a href="#" class="image">
							<img width="45%" height="45%" src="images/Sistemas-Centralizados.png" alt="Sistemas Centralizados" />
						</a>
					</section>
					<section>
						<h2>Sistemas distribuidos</h2>
						<ul>
							<li>En un sistema distribuido, los clientes replican completamente el repositorio.</li>
							<li>Si un servidor falla, el servidor se puede restaurar con cualquier copia de los clientes.</li>
							<li>Cada rama/tag creado sólo hace una instantánea respecto al estado anterior.</li>
						</ul>
						<a href="#" class="image">
							<img width="35%" height="35%" src="images/Sistemas-Distribuidos.png" alt="Sistemas Distribuidos" />
						</a>
					</section>
				</section>

				<section>
					<h2>Historia de GIT</h2>
					<p>
						GIT surge a partir de la necesidad de gestionar el código fuente del <strong>núcleo de Linux</strong>.
					</p>
					<p>
						Durante muchos años Linux utilizó un sistema propietario denominado BitKeeper, pero Linus Torvalds decidó desarrollar un sistema propio enfocado en:
					</p>
					<br />
					<ul>
						<li>Velocidad</li>
						<li>Diseño sencillo</li>
						<li>Fuerte apoyo al desarrollo no lineal (ramas paralelas)</li>
						<li>Completamente distribuido</li>
						<li>Capaz de manejar grandes proyectos de manera eficiente</li>
					</ul>
				</section>
				
				<section>
					<section>
						<h2>Fundamentos de GIT</h2>
						<p>
							Entonces... ¿cómo trabaja GIT? 
						</p>
						<ul>
							<li>Genera instantáneas, no diferencias.</li>
							<li>Casi todas las operaciones son locales.</li>
							<li>Tiene integridad.</li>
							<li>Sólo se añade información.</li>
							<li>Tres estados.</li>
						</ul>
					</section>
					<section>
						<h2>Genera instantáneas, no diferencias.</h2>
						<p>
							Cada vez que se confirma un cambio, GIT hace una foto del aspecto de los archivos en ese momento y guarda una referencia a esa instantánea. Los archivos no modificados no son almacenados de nuevo.
						</p>
						<a href="#" class="image">
							<img width="500" height="222" src="images/18333fig0105-tn.png" alt="Instantáneas en GIT" />
						</a>
					</section>
					<section>
						<h2>Casi todas las operaciones son locales.</h2>
						<p>
							La mayoría de las operaciones en Git sólo necesitan archivos y recursos locales para operar. Por ejemplo:
						</p>
						<ul>
							<li>Por ejemplo, para navegar por la historia del proyecto, Git no necesita salir al servidor para obtener la historia y mostrártela, simplemente la lee directamente de tu base de datos local</li>
							<li>También significa que hay muy poco que no puedas hacer si estás desconectado o sin VPN</li>
						</ul>
					</section>
					<section>
						<h2>Tiene integridad.</h2>
						<p>
							Todo en Git es verificado mediante el <strong>checksum</strong> antes de ser almacenado, y es identificado a partir de ese momento
							mediante dicha suma. Esto significa que es imposible cambiar los contenidos de cualquier archivo o directorio sin que Git lo sepa.
						</p>
						<p>
							De hecho, de forma interna, GIT guarda todo no por el nombre del archivo, si no por el hash de dicho archivo.
						</p>
					</section>
					<section>
						<h2>Sólo se añade información.</h2>
						<p>
							Cuando realizas acciones en Git, casi todas ellas sólo añaden información a la base de datos de Git. Es muy difícil conseguir que 
							el sistema haga algo que no se pueda deshacer, o que de algún modo borre información.
						</p>
						<p>
							Esto hace que usar Git sea muy agradable, porque sabemos que podemos experimentar sin peligro de fastidiar gravemente las cosas.
						</p>
					</section>
					<section>
						<h2>Tres estados (I).</h2>
						<p>
							Git tiene tres estados principales en los que se pueden encontrar tus archivos: <strong>confirmado</strong> (committed), <strong>modificado</strong> (modified), y <strong>preparado</strong> (staged).
						</p>
						<br />
						<ul>
							<li>Confirmado significa que los datos está almacenados de forma segura en la base de datos local.</li>
							<li>Modificado significa que has cambiado un archivo pero todavía no lo has confirmado a tu base de datos.</li>
							<li>Preparado significa que has marcado un archivo modificado en su versión actual para que vaya en la próxima confirmación.</li>
						</ul>
					</section>
					<section>
						<h2>Tres estados (II).</h2>
						<p>
							El flujo de trabajo sería:
						</p>
						<ol>
							<li>Modificas una serie de archivos en tu directorio de trabajo.</li>
							<li>Preparas los archivos, añadiendolos a tu área de preparación.</li>
							<li>Confirmas los cambios, lo que toma los archivos tal y como están en el área de preparación, y almacena esas instantáneas de manera permanente en tu directorio de Git.</li>
						</ol>
						<br /><br />
						<a href="#" class="image">
							<img width="40%" height="40%" src="images/18333fig0106-tn.png" alt="Los tres estados" />
						</a>
					</section>
				</section>
				
				<section>
					<section>
						<h2>Trabajar con GIT</h2>
						<p>
							Para empezar a trabajar con GIT necesitaremos las siguientes herramientas:											
						</p>
						<ul>
							<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html" target="_blank">Suite Putty</a> (Windows)</li>
							<li><a href="http://www.sourcetreeapp.com/" target="_blank">SourceTree</a> (Windows / Mac) - Cliente</li>
							<li><a href="http://git-scm.com/download/win" target="_blank">GIT Command line tools</li>
						</ul>
					</section>
					<section>
						<h2>Autenticación</h2>
						<p>
							Para la generación de los certificados necesarios para la autenticación en servidores GIT utilizaremos:
						</p>
						<ul>
							<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html" target="_blank">PuTTYgen</a> (Windows)</li>							
							<li>ssh-keygen (Mac / Linux)</li>							
						</ul>
						<br /><br />
						<blockquote>
							La generación de certificados permite conectarse al servidor GIT utilizando una conexión SSH. Este tipo de conexión es la recomendada en términos de seguridad.
						</blockquote>
						<br />
						<blockquote>
							Las claves SSH permiten que dos ordenadores se identifiquen entre si, sin la necesidad de introducir contraseñas.
						</blockquote>
					</section>
					<section>
						<h2>Cliente GIT</h2>
						<p>
							Como cliente GIT utilizaremos <strong>SourceTree</strong> desarrollado por Atlassian.						
						</p>
						<br />
						<ul>
							<li>Cliente con UI muy descriptiva que muestra todas las ramas/tags creadas y las interacciones entre ellas</li>
							<li>Permite navegar de forma visual por el histórico del proyecto</li>
							<li>Permite realizar comandos complejos con un simple clic del ratón</li>
							<li>Ampliamente extendido y compatible tanto con GIT como con Mercurial.</li>
						</ul>
						<a href="#" class="image">
							<img width="275px" height="63px" src="images/logoSourceTree.png" style="background-color:white" alt="Logo de GIT" />
						</a>
					</section>
					
					<section>
						<h2>Servidor GIT</h2>
						<p>Podremos trabajar con cualquier servidor GIT. Algunos de los más populares son:</p>
						<br />
						<ul>
							<li>GitHub - <a href="http://www.github.com" target="_blank">http://www.github.com</a></li>
							<li>BitBucket - <a href="https://bitbucket.org/" target="_blank">https://bitbucket.org/</a></li>
							<li>Servidor GIT propio - <a href="https://about.gitlab.com/" target="_blank">GitLab</a></li>
						</ul>
					</section>
				</section>
				
				<section>
					<section>
						<h2>Creación de un repositorio</h2>
						<p>
							Tarea que se realiza al inicio del proyecto o durante la vida del proyecto si se subdivide en distintos módulos. Como ejemplo vamos a crear un proyecto en GitLab:
						</p>
						<a href="#" class="image">
							<img width="90%" height="90%" src="images/NuevoRepositorio.png" alt="Nuevo repositorio" />
						</a>
					</section>
				</section>
				
				<section>
					<section>
						<h2>Creación de las claves SSH</h2>
						<p>
							La autenticación con GIT la podemos realizar de dos formas: claves SSH o mediante login/password.
						</p>
						<br />
						<p>
							La autenticación mediante claves SSH es preferible en términos de seguridad y comodidas para el usuario, ya que una 
							vez generados los juegos de claves pública / privada e informado al servidor, el cliente SourceTree se encargará de 
							todo lo relativo a la autenticación.
						</p>
					</section>
					<section>
						<h2>Creación de las claves SSH</h2>
						<p>
							La URL del repositorio nos indica el tipo de login a realizar:
						</p>
						<br />
						<ol>
							<li class="fragment"><code>git@git.connectis-ict.es:aireuropa_casillero_digital/mod-middleware.git</code></li>
							<li class="fragment"><code>https://gitlab.connectis-ict.es/aireuropa_casillero_digital/mod-middleware.git</code></li>
						</ol>			
					</section>
					<section>
						<h2>Creación de las claves SSH</h2>
						<p>
							Creación de las claves SSH en Windows:
						</p>
						<br />
						<a href="#" class="image">
							<img width="1024px" height="500px" src="images/puttygen.gif" alt="Creación claves SSH" />
						</a>			
					</section>
					<section>
						<h2>Creación de las claves SSH</h2>
						<p>
							Como resultado de la creación de las claves SSH en Windows obtendremos 3 archivos:
						</p>
						<br />
						<ol>
							<li class="fragment"><code>ssh_key.pub</code> - clave publica</li>
							<li class="fragment"><code>ssh_key.ppk</code> - clave privada</li>
							<li class="fragment"><code>ssh_key.txt</code> - Información de las claves para el servidor GIT</li>
						</ol>		
					</section>
					<section>
						<h2>Creación de las claves SSH</h2>
						<p>
							Una vez creadas las claves SSH, debemos informar al servidor GIT de las mismas para que nos permita el acceso:
						</p>
						<br />
						<a href="#" class="image">
							<img width="95%" height="95%" src="images/addssh.gif" alt="Añadir clave SSH" />
						</a>		
					</section>					
				</section>

				<section>
					<section>
						<h2>Operaciones básicas (I)</h2>
						<h3>Obtener un repositorio: clonado</h3>
						<p>
							Es la primera operación a realizar sobre un repositorio. Para obtener una copia de un repositorio existente al que se desea contribuir el comando 
							a utilizar es <strong>clone</strong>.
						</p>
						<br />
						<p>
							Clonar significa realizar una copia de todo el contenido del repositorio que se encuentra en el servidor GIT en nuestro PC.
						</p>
						<br />
						<p>
							A diferencia de otros sistemas (SVN), se obtiene una copia completa del repositorio del servidor, de forma que se podrá trabajar
							sin necesidad de conexión.
						</p>
						<pre>
							<code data-trim contenteditable>
mkdir git-training
cd git-training							
git clone git@git.connectis-ict.es:fjordan/git-training.git
							</code>
						</pre>
					</section>
					<section>
						<h2>Operaciones básicas (I)</h2>
						<h3>Clonado con SourceTree</h3>
						<p>
							Se debe utilizar el botón de la barra de herramientas "Clone / New".
						</p>
						<a href="#" class="image"><img width="80px" height="58px" src="images/BotonClone.png" alt="Botón Clonar repositorio" /></a>
						<br />
						<a href="#" class="image">
							<img width="70%" height="70%" src="images/Clone.png" alt="Clonar repositorio" />
						</a>
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (II)</h2>
						<h3>Estado de los archivos</h3>
						<p>
							Tu principal herramienta para determinar qué archivos están en qué estado es el comando <strong>git status</strong>. 
							Si ejecutas este comando justo después de clonar un repositorio, deberías ver algo así:
						</p>
						<pre>
							<code data-trim contenteditable>	
cd git-training							
git status
# On branch master
nothing to commit, working directory clean
							</code>
						</pre>
						<p>
							Esto significa que tienes un directorio de trabajo limpio —en otras palabras, no tienes archivos bajo seguimiento y modificados—. GIT tampoco ve ningún archivo que no esté bajo seguimiento, o estaría listado ahí. Por último, el comando te dice en qué rama estás. Por ahora, esa rama siempre es "master", que es la predeterminada.
						</p>						
					</section>
					
					<section>
						<h2>Operaciones básicas (II)</h2>
						<h3>Estado de los archivos con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (III)</h2>
						<h3>Seguimiento de archivos</h3>
						<p>
							Para empezar el seguimiento de un nuevo archivo se usa el comando<br /><strong>git add</strong>.<br />
							Iniciaremos el seguimiento del archivo README ejecutando esto:
						</p>
						<pre>
							<code data-trim contenteditable>	
touch README						
cd git-training							
git add README
							</code>
						</pre>
						<p>
							Si vuelves a ejecutar el comando git status, verás que tu README está ahora bajo seguimiento y preparado:
						</p>	
						<pre>
							<code data-trim contenteditable>							
git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#   new file:   README
#
							</code>
						</pre>						
					</section>
					
					<section>
						<h2>Operaciones básicas (III)</h2>
						<h3>Seguimiento de archivos con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (IV)</h2>
						<h3>Modificar archivos</h3>
						<p>
							Vamos a modificar un archivo que ya estuviese bajo seguimiento. 
							Si, por ejemplo, modificamos el archivo MiArchivo.txt que ya está bajo seguimiento, y ejecutamos el comando <strong>git status</strong> de nuevo, veremos algo así:
						</p>
						<pre>
							<code data-trim contenteditable>							
git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#   new file:   README
#
# Changes not staged for commit:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#
#   modified:   MiArchivo.txt
#
							</code>
						</pre>										
					</section>
					
					<section>
						<h2>Operaciones básicas (IV)</h2>
						<h3>Modificar archivos</h3>
						<p>
							El archivo <strong>MiArchivo.txt</strong> aparece bajo la cabecera "Modificados pero no actualizados" ("Changes not staged for commit") —esto significa que un archivo bajo seguimiento ha sido modificado en el directorio de trabajo, pero no ha sido preparado todavía—. 
						</p>
						<p>
							Para prepararlo, ejecuta el comando<br /><strong>git add</strong><br />y volvemos a ejecutar <strong>git status</strong>:
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git add MiArchivo.txt
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#   new file:   README
#   modified:   MiArchivo.txt
#
							</code>
						</pre>										
					</section>
					
					<section>
						<h2>Operaciones básicas (IV)</h2>
						<h3>Modificar archivos con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (V)</h2>
						<h3>Ignorar archivos</h3>
						<p>
							A menudo tendrás un tipo de archivos que no quieras que GIT añada automáticamente o te muestre como no versionado. 
							Suelen ser archivos generados automáticamente, como archivos de log, o archivos generados por tu compilador. 
						</p>
						<p>
							Para estos casos puedes crear un archivo llamado <strong>.gitignore</strong>, en el que listas los patrones de nombres que deseas que sean ignorados. 
							por ejemplo:
						</p>
						<pre>
							<code data-trim contenteditable>							
$ cat .gitignore
*.sh
*.class
target/
							</code>
						</pre>			
					</section>
					<section>
						<h2>Operaciones básicas (V)</h2>
						<h3>Ignorar archivos: reglas</h3>
						<ol>
							<li>las líneas en blanco o que comienzan por # son ignoradas.</li>
							<li>Se pueden usar patrones para indicar nombres de archivos o directorios.</li>
							<li>Se pueden ignorar directorios completos añadiendo / al final</li>
							<li>Se puede negar un patrón añadiendo una exclamación ! al principio.</li>
						</ol>
						<pre>
							<code data-trim contenteditable>							
# un comentario – esta línea es ignorada
# no permitir archivos con extensión .a
*.a
# autorizar el archivo lib.a, incluso aunque no se permitan los archivos .a
!lib.a
# ignorar el archivo TODO que está en el raíz, pero no otros (por ejemplo subdir/TODO)
/TODO
# ignorar todos los archivos en la carpeta build/
build/
# ignorar los archivos txt (ejemplo: doc/notes.txt) en el primer nivel de la carpeta, pero permitir doc/server/arch.txt
doc/*.txt
# ignorar todos los archivos .txt de la carpeta doc/
doc/**/*.txt
							</code>
						</pre>
					</section>					
					
					<section>
						<h2>Operaciones básicas (V)</h2>
						<h3>Ignorar archivos con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (VI)</h2>
						<h3>Confirmar cambios</h3>
						<p>
							Ahora que el área de preparación está como tú quieres, podemos confirmar los cambios. Hay que recordar que cualquier cosa que esté sin preparar no se incluirá ne la confirmación de archivos.
						</p>
						<br />
						<p>
							La forma más fácil de confirmar es escribiendo<br /><strong>git commit -m &lt;comentario&gt;</strong>:
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git commit -m "Story 182: Fix benchmarks for speed"
[master]: created 463dc4f: "Fix benchmarks for speed"
 2 files changed, 3 insertions(+), 0 deletions(-)
 create mode 100644 README
							</code>
						</pre>										
					</section>
													
					<section>
						<h2>Operaciones básicas (VI)</h2>
						<h3>Confirmar cambios con SourceTree</h3>
						TODO !!
					</section>
				</section>												
								
				<section>
					<section>
						<h2>Operaciones básicas (VII)</h2>
						<h3>¿Qué es una rama en GIT?</h3>
						<p>
							En cada commit, GIT almacena un punto de control que conserva: un puntero a la copia puntual de los contenidos, metadatos del autor y el mensaje. 
							Con cada commit, GIT realiza una fotografía del estado actual del repositorio.
						</p>
						<a href="#" class="image">
							<img width="50%" height="50%" src="images/18333fig0302-tn.png" alt="Ramas en GIT" />
						</a>
						<blockquote>
							Una rama Git es simplemente un puntero móvil apuntando a una de esas confirmaciones. La rama por defecto de Git es la rama <strong>master</strong>.
						</blockquote>
					</section>
								
					<section>
						<h2>Operaciones básicas (VII)</h2>
						<h3>Crear ramas</h3>
						<p>
							Con GIT podemos crear ramas fácilmente gracias al comando:<br /><strong>git branch &lt;nombre&gt;</strong>
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git branch testing
							</code>
						</pre>	
						<a href="images/18333fig0305-tn.png" class="image">
							<img width="40%" height="40%" src="images/18333fig0305-tn.png" alt="Crear Ramas en GIT" />
						</a>
						
						<blockquote>
							IMPORTANTE! Este comando sólo crea una nueva rama, no nos sitúa en ella. 
						</blockquote>	

						<aside class="notes">
							Explicar el puntero HEAD: E sun puntero que indica a GIT en que rama se encuentra el usuario en cada momento.
						</aside>						
					</section>
					
					<section>
						<h2>Operaciones básicas (VII)</h2>
						<h3>Ramas con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (VIII)</h2>
						<h3>Cambios entre ramas</h3>
						<p>
							Para pasar de una rama a otra, utilizaremos el comando<br /><strong>git checkout &lt;rama&gt;</strong>
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git checkout testing
							</code>
						</pre>
						<a href="#" class="image">
							<img width="40%" height="40%" src="images/18333fig0306-tn.png" alt="Cambiar entre ramas" />
						</a>
					</section>
								
					<section>
						<h2>Operaciones básicas (VIII)</h2>
						<h3>Commit sobre ramas</h3>
						<p>
							A partir de este momento, cualquier commit que se realice será sobre la rama activa, en nuestro caso "testing"
						</p>
						<pre>
							<code data-trim contenteditable>							
$ vim test.rb
$ git commit -a -m 'made a change'
							</code>
						</pre>	
						<a href="images/18333fig0307-tn.png" class="image">
							<img width="50%" height="50%" src="images/18333fig0307-tn.png" alt="Crear Ramas en GIT" />
						</a>	

						<aside class="notes">
							Explicar que estos gráficos de GIT, las flechas se leen en dirección contraria.
						</aside>						
					</section>
					
					<section>
						<h2>Operaciones básicas (VIII)</h2>
						<h3>Cambio de rama</h3>
						<p>
							¿Qué sucede si ahora queremos volver a la rama anterior "master"?
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git checkout master
							</code>
						</pre>	
						<a href="images/18333fig0308-tn.png" class="image">
							<img width="60%" height="60%" src="images/18333fig0308-tn.png" alt="Crear Ramas en GIT" />
						</a>	

						<aside class="notes">
							Explicar que en este momento estamos "por detrás" del ultimo commit realizado y que la información enviada .
						</aside>						
					</section>
					
					<section>
						<h2>Operaciones básicas (VIII)</h2>
						<h3>Commit sobre ramas</h3>
						<p>
							Si hacemos algún cambio sobre la rama actual... ¿donde se almacenará? ¿cómo quedará nuestro repositorio?
						</p>
						<pre>
							<code data-trim contenteditable>							
$ vim test.java
$ git commit -a -m 'hacemos algunos cambios'
							</code>
						</pre>	
						<a href="images/18333fig0309-tn.png" class="image">
							<img width="45%" height="45%" src="images/18333fig0309-tn.png" alt="Crear Ramas en GIT" />
						</a>							
					</section>
					
					<section>
						<h2>Operaciones básicas (VIII)</h2>
						<h3>Ramas con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<!-- TAGS -->
				<section>
					<section>
						<h2>Operaciones básicas (IX)</h2>
						<h3>Listar etiquetas</h3>
						<p>
							Con GIT se pueden crear etiquetas (marcas) en puntos específicos de la historia del repositorio. Para ello utilizaremos el comando <strong>git tag</strong>. Por ejemplo, para listar las etiquetas del repositorio actual:
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git tag
v0.1
v1.3
							</code>
						</pre>	
						<p>
							O podemos buscar una etiqueta utilizando un patrón de búsqueda: <strong>git tag -l &lt:patrón&gt;</strong>
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git tag -l 'v1.4.2.*'
v1.4.2.1
v1.4.2.2
v1.4.2.3
v1.4.2.4
							</code>
						</pre>						
					</section>
								
					<section>
						<h2>Operaciones básicas (IX)</h2>
						<h3>Crear etiquetas</h3>
						<p>
							Con GIT podemos crear etiquetas en nuestra rama de trabajo gracias al comando:<br /><strong>git tag -a &lt;nombre&gt; -m &lt;mensaje&gt;</strong>
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git tag -a v1.4 -m 'my version 1.4'
$ git tag
v0.1
v1.3
v1.4
							</code>
						</pre>	
						<p>
							Este tipo de etiquetas se denominan <italic>etiquetas anotadas</italic>, se almacenan como objetos complejos en la base de datos de GIT: 
							tienen checksum, mensaje de etiquetado, fecha, autor, etc...
						</p>											
					</section>
					
					<section>
						<h2>Operaciones básicas (IX)</h2>
						<h3>Etiquetas con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (XI)</h2>
						<h3>Publicar cambios</h3>
						<p>
							Cuando se quiere compartir una rama o un conjunto de cambios con el resto del mundo, se debe enviar a un servidor remoto (<strong>push</strong>).
							Los cambios realizados sobre las ramas locales NO se sincronizan automáticamente con los remotos, hay que enviarlo (<strong>push</strong>) expresamente.
							<br />
							Por ejemplo, supongamos que tenemos cambios que queremos publicar en una rama llamada "testing":<br />
							<strong>git push &lt;remoto&gt; &lt;rama&gt;</strong>
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git push origin testing
Counting objects: 20, done.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (15/15), 1.74 KiB, done.
Total 15 (delta 5), reused 0 (delta 0)
To git@gitlab.com:fjordan/git-training.git
 * [new branch]      testing -> testing
							</code>
						</pre>		

						<aside class="notes">
							Explicar que en el ejemplo "origin" hace referencia al remoto principal y que puede haber más de un remoto configurado.
						</aside>						
					</section>
					
					<section>
						<h2>Operaciones básicas (XI)</h2>
						<h3>Publicar con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Operaciones básicas (XI)</h2>
						<h3>Recuperar cambios</h3>
						<p>
							Activando (checkout) una rama local a partir de una rama remota, se crea automáticamente lo que podríamos denominar "una rama de seguimiento" (tracking branch). 
							Las ramas de seguimiento son ramas locales que tienen una relación directa con alguna rama remota.
						</p>
						<br />
						<p>
							Cuando queremos actualizar los contenidos de nuestro local con los contenidos del remoto, debemos utilizar el comando:<br />
							<strong>git pull</strong>
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git pull
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (14/14), done.
remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15/15), done.
From git@gitlab.com:fjordan/git-training
 * [new branch]      serverfix    -> origin/serverfix
							</code>
						</pre>		

						<aside class="notes">
							Explicar que en el ejemplo "origin" hace referencia al remoto principal y que puede haber más de un remoto configurado.
						</aside>						
					</section>
					
					<section>
						<h2>Operaciones básicas (XI)</h2>
						<h3>Recuperar cambios con SourceTree</h3>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Secuencia de trabajo</h2>
						<p>
							En el día a día, para realizar las tareas más comunes utilizaremos esta secuencia de comados sobre la rama de trabajo en curso:
						</p>
						<br />
						<p>
							Añadir cambios al repositorio:
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git add .
$ git commit -m &lt;mensaje&gt;
$ git push origin &lt;rama&gt;
							</code>
						</pre>		

						<p>
							Obtener cambios del repositorio:
						</p>
						<pre>
							<code data-trim contenteditable>							
$ git pull
							</code>
						</pre>						
					</section>
					
					<section>
						<h2>Secuencia de trabajo con SourceTree</h2>
						TODO !!
					</section>
				</section>
				
				<section>
					<section>
						<h2>Git Flow</h2>
						<p>
							El elemento principal de trabajo con GIT son las ramas. En ellas vamos a ir almacenando todos los elementos de nuestro proyecto:
							Releases, Fixes, nuevas Features, experimentos, etc. Necesitamos una forma de organizar el trabajo ordenada y que nos permite poder 
							tener una trazabilidad y seguimiento del proyecto.
						</p>
						<br />
						<blockquote>
							Git Flow es una extensión de GIT que facilita la gestión de ramas y flujos de trabajo.
						</blockquote>
					</section>
					
					<section>
						<h2>Git Flow</h2>
						<p>
							Elementos básicos en Git Flow:
						</p>
						<br />
						<ol>
							<li><strong>Rama master:</strong> Cualquier commit que se realice sobre esta rama debe estar preparado para subir a producción.</li>
							<li><strong>Rama develop:</strong> En esta rama estará el código que formará parte de la siguiente versión del software.</li>
							<li>
								Ramas auxiliares:
								<ul>
									<li><strong>Feature:</strong> Rama de trabajo, suponen nuevas características que en algún momento serán añadidas a la rama develop.</li>
									<li><strong>Release:</strong> Ramas asociada a una release del proyecto. Irá asociada a los tags de versión y en ella se integrarán los parches urgentes de producción.</li>
									<li><strong>Hotfix: </strong> Solución a fallos de producción.</li>
								</ul>
							</li>
						</ol>
					</section>
					
					<section>
						<h2>Git Flow en SourceTree</h2>
						<p>
							Para activar Git Flow en el proyecto, pulsamos su botón en la barra de herramientas:
						</p>
						<a href="images/MetodologiaTags.png" class="image"><img width="66px"src="images/BotonGitFlow.png" alt="Activación de Git Flow" /></a>
						<br />
						<p>
							La primera vez que lo utilicemos, nos preguntará los nombres de las ramas/etiquetas a utilizar. Dejamos los valores por defecto:
							<a href="images/MetodologiaTags.png" class="image">
								<img width="421px"src="images/ConfiguracionGitFlow.png" alt="Activación de Git Flow" />
							</a>
						</p>
					</section>
					
					<section>
						<h2>Git Flow en SourceTree</h2>
						<p>
							Una vez configurado Git Flow, para cualquier rama o etiqueta nueva que necesitemos, al pulsar el botón nos preguntará:
						</p>
						<a href="#" class="image"><img width="250px"src="images/CreacionElementoGitFlow.png" alt="Uso de Git Flow" /></a>						
					</section>
					
					<section>
						<h2>Git Flow en SourceTree</h2>
						<p>
							Una vez finalizada la rama en la que estamos trabajando, al pulsar el botón nos preguntará:
						</p>
						<a href="#" class="image"><img width="250px"src="images/FinalizacionGitFlow.png" alt="Uso de Git Flow" /></a>						
					</section>
				</section>
				
				<section>
					<section>
						<h2>Metodología de trabajo (I)</h2>
						<blockquote>
							La metodología de trabajo propuesta irá asociada al uso en el proyecto de Git Flow.
						</blockquote>
						<br />
						<p>
							Se utilizarán todos los tipos de ramas disponibles en Git Flow más un conjunto personalizado de etiquetas:
						</p>
						<br />
						<ol>
							<li><strong>Rama master:</strong> Asociada al contenido actual en producción.</li>
							<li><strong>Rama develop:</strong> Asociada a la siguiente versión del software.</li>
							<li>
								Ramas auxiliares:
								<ul>
									<li><strong>Feature:</strong> Rama de trabajo actual del proyecto.</li>
									<li><strong>Release:</strong> Ramas asociada a una release del proyecto.</li>
									<li><strong>Hotfix: </strong> Solución a fallos de producción.</li>
								</ul>
							</li>
						</ol>
					</section>
					
					<section>
						<h2>Metodología de trabajo (II)</h2>						
						<p>
							Un proyecto típico tendrá esta apariencia:
						</p>
						<br />
						<a href="images/MetodologiaTags.png" class="image">
							<img width="220px"src="images/MetodologiaRamas.png" alt="Metodología" />
						</a>
					</section>
					
					<section>
						<h2>Metodología de trabajo (III)</h2>
						<h3>Ramas</h3>
						<p>
							Las ramas de tipo <strong>feature</strong> tendrán las siguientes características:
						</p>
						<br />
						<ol>
							<li>Se deben originar desde la rama <strong>develop</strong></li>
							<li>Una vez finalizadas, su código se incorporará a la rama <strong>develop</strong></li>
							<li>Su nombre irá asociado al sistema de gestión de proyectos. Por ejemplo, una tarea en Redmine con enlace
								<br /><br />
								<center>https://&lt;dirección del servidor&gt;/issues/5531</center>
								<br /><br />
								nos producirá una rama con nombre
								<br /><br />
								<center><strong>feature/5531</strong></center>
							</li>															
						</ol>
					</section>
					
					<section>
						<h2>Metodología de trabajo (IV)</h2>
						<h3>Ramas</h3>
						<p>
							Las ramas de tipo <strong>release</strong> tendrán las siguientes características:
						</p>
						<br />
						<ol>
							<li>Se deben originar desde la rama <strong>develop</strong></li>
							<li>Una vez finalizadas, su código se incorporará a la rama <strong>develop</strong></li>
							<li>Su nombre irá asociado a la versión del software que se publica.</li>
							<li>Se debe utlizar notación semántica de tres dígitos X.Y.Z junto al nombre de la rama. El último dígito se deja sin definir ya que en esta rama se incorporarán los fixes necesarios para que el código se pueda pasar a producción con garantías.</li>
						</ol>
						<br /><br />
						<p>
							Ejemplo: <strong>release/1.2.x</strong>
						</p>
					</section>
					
					<section>
						<h2>Metodología de trabajo (V)</h2>
						<h3>Ramas</h3>
						<p>
							Las ramas de tipo <strong>hotfix</strong> tendrán las siguientes características:
						</p>
						<br />
						<ol>
							<li>Se deben originar desde la rama <strong>master</strong></li>
							<li>Una vez finalizadas, su código se incorporará a la rama <strong>master</strong> (si han sido 100% verificados los cambios) o a la rama <strong>develop</strong> (si hay que realizar pruebas antes del paso a producción)</li>
							<li>Su nombre irá asociado al sistema de gestión de proyecto: Por ejemplo, una tarea en Redmine con enlace
								<br /><br />
								<center>https://&lt;dirección del servidor&gt;/issues/5531</center>
								<br />
								producirá una rama con nombre
								<br /><br />
								<center><strong>hotfix/5531</strong></center>
							</li>
						</ol>
					</section>
					
					<section>
						<h2>Metodología de trabajo (VI)</h2>
						<h3>Etiquetas</h3>
						<p>
							Durante el ciclo de vida del proyecto, se establecerán las siguientes etiquetas para una versión X.Y.Z del proyecto:
						</p>
						<br />
						<a href="images/MetodologiaTags.png" class="image">
							<img width="300px"src="images/MetodologiaTags.png" alt="Metodología" />
						</a>
					</section>
					
					<section>
						<h2>Metodología de trabajo (VII)</h2>
						<h3>Etiquetas</h3>
						<ol>
							<li><strong>X.Y.Z/KO</strong> - <i>Kick Off</i> de la versión del proyecto. Supone el punto de partida de una nueva versión del software.</li>
							<li><strong>X.Y.Z/CC</strong> - <i>Code Complete</i> de la versión del proyecto. Supone la finalización de las tareas de programación y es previo a las pruebas del software. A partir de este punto los commits que se realicen serán solución a bugs y no incluirán nuevas features.</li>
							<li><strong>X.Y.Z/RFFI</strong> - <i>Ready For Final Integration</i>. Supone la finalización de las pruebas internas del software y el inicio de las pruebas del cliente (si las realiza). A partir de este punto los commits que se realicen serán solución a bugs detectados por el cliente y no incluirán nuevas features.</li>
							<li><strong>X.Y.Z/RA</strong> - <i>Release Acceptance</i>. Esta etiqueta indica que el software ha sido aceptado por el cliente y no se realizará más desarrollo sobre esta versión.</li>
						</ol>
					</section>
				</section>

				<section>
					<a href="#" class="image">
						<img width="1000px"src="images/ask-question.jpg" alt="Preguntas" />
					</a>
				</section>
				
				<section>
					<h1>FIN</h1>
					<p>
						<small>Por <a href="mailto:fernando.jordan@connectis-ict.es">Fernando Jordán</a> / <a href="http://twitter.com/fjordansilva">@fjordansilva</a></small>
					</p>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,	
				slideNumber: true,		
				hideAddressBar: true,
				center: true,
				
				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				width: 1024,
				height: 700,
				
				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '4200px 1800px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
		</script>

	</body>
</html>
